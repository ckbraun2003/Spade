#version 430
layout(local_size_x = 16, local_size_y = 16) in;

struct RayPayload {
    vec3 origin;
    vec3 direction;
    vec3 throughput;
    uint rayActive; // using uint for bool alignment
};

struct HitInfo {
    float t;
    int instanceIndex;
    int primitiveIndex; 
    uint materialIndex; // NEW
    vec3 normal;
};

// SSBOs
layout(std430, binding = 2) buffer RayBuffer { RayPayload rays[]; };
layout(std430, binding = 3) buffer HitBuffer { HitInfo hits[]; };

// Image (readonly for size query)
layout(binding = 0, rgba32f) uniform image2D imgOutput;


struct GPUSphere {
    vec4 centerRadius;
    uint materialIndex;
    float padding[3];
};

struct GPUTriangle {
    vec4 v0;
    vec4 v1;
    vec4 v2;
    uint materialIndex;
    float padding[3];
};

layout(std430, binding = 4) buffer SphereBuffer { GPUSphere spheres[]; };
layout(std430, binding = 5) buffer TriangleBuffer { GPUTriangle triangles[]; };

uniform uint u_NumSpheres;
uniform uint u_NumTriangles;

// Intersect Sphere
float IntersectSphere(vec3 ro, vec3 rd, vec4 s) {
    vec3 oc = ro - s.xyz;
    float b = dot(oc, rd);
    float c = dot(oc, oc) - s.w * s.w;
    float h = b*b - c;
    if(h < 0.0) return -1.0;
    return -b - sqrt(h);
}

// Intersect Triangle (Möller–Trumbore algorithm)
float IntersectTriangle(vec3 ro, vec3 rd, vec4 v0, vec4 v1, vec4 v2) {
    vec3 e1 = v1.xyz - v0.xyz;
    vec3 e2 = v2.xyz - v0.xyz;
    vec3 s = ro - v0.xyz;

    vec3 h = cross(rd, e2);
    float a = dot(e1, h);

    if (a > -0.00001 && a < 0.00001) return -1.0; // Parallel

    float f = 1.0 / a;
    float u = f * dot(s, h);

    if (u < 0.0 || u > 1.0) return -1.0;

    vec3 q = cross(s, e1);
    float v = f * dot(rd, q);

    if (v < 0.0 || u + v > 1.0) return -1.0;

    float t = f * dot(e2, q);

    if (t > 0.00001) return t;

    return -1.0;
}

void main() {
    // 2D to Linear Index
    ivec2 dims = imageSize(imgOutput);
    uint width = dims.x;
    uint rayIdx = gl_GlobalInvocationID.y * width + gl_GlobalInvocationID.x;
    
    // Bounds check
    if(gl_GlobalInvocationID.x >= width || gl_GlobalInvocationID.y >= dims.y) return;
    
    RayPayload ray = rays[rayIdx];
    if (ray.rayActive == 0) return;

    float closestT = 1e30;
    int closestPrimitive = -1;
    int closestInstance = -1; // 0=Sphere, 1=Triangle
    uint closestMaterial = 0;
    vec3 normal = vec3(0);

    // 1. Intersect Spheres
    for(uint i = 0; i < u_NumSpheres; ++i) {
        GPUSphere s = spheres[i];
        float t = IntersectSphere(ray.origin, ray.direction, s.centerRadius);
        if(t > 0.0 && t < closestT) {
            closestT = t;
            closestPrimitive = int(i);
            closestInstance = 0; // Sphere
            closestMaterial = s.materialIndex;
            normal = normalize((ray.origin + ray.direction * t) - s.centerRadius.xyz);
        }
    }

    // 2. Intersect Triangles
    for(uint i = 0; i < u_NumTriangles; ++i) {
        GPUTriangle tri = triangles[i];
        float t = IntersectTriangle(ray.origin, ray.direction, tri.v0, tri.v1, tri.v2);
        if(t > 0.0 && t < closestT) {
            closestT = t;
            closestPrimitive = int(i);
            closestInstance = 1; // Triangle
            closestMaterial = tri.materialIndex;
            
            // Calculate Flat Normal
            vec3 e1 = tri.v1.xyz - tri.v0.xyz;
            vec3 e2 = tri.v2.xyz - tri.v0.xyz;
            normal = normalize(cross(e1, e2));
        }
    }

    // Write Hit
    if(closestPrimitive != -1) {
        hits[rayIdx].t = closestT;
        hits[rayIdx].primitiveIndex = closestPrimitive;
        hits[rayIdx].instanceIndex = closestInstance;
        hits[rayIdx].materialIndex = closestMaterial;
        hits[rayIdx].normal = normal;
    } else {
        hits[rayIdx].primitiveIndex = -1;
    }
}
