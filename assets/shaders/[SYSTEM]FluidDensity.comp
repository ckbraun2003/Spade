#version 430 core

layout(local_size_x = 64) in;

// --- Structs ---
struct Transform {
    vec3 position;
    vec4 rotation;
    vec3 scale;
};

struct Motion {
    vec3 velocity;
    float mass;
    vec3 acceleration;
    float density;
};

struct FluidMaterial {
    float restDensity;
    float viscosity;
    float stiffness;
    uint isActive;
};

struct GridPair {
    uint cellID;
    uint instanceID;
};

// --- Buffers ---
layout(std430, binding = 11) buffer SortedTransforms {
    Transform sortedTransforms[];
};
layout(std430, binding = 12) buffer SortedMotions {
    Motion sortedMotions[];
};
layout(std430, binding = 8) buffer InstanceToEntityIndex {
    uint instanceToEntityIndex[];
};
layout(std430, binding = 13) buffer EntityFluidMaterials {
    FluidMaterial entityFluidMaterials[];
};

layout(std430, binding = 9) buffer GridHead {
    int gridHead[];
};
layout(std430, binding = 10) buffer GridPairs {
    GridPair gridPairs[];
};

// --- Uniforms ---
uniform float globalBounds;
uniform float cellSize;
uniform uint hashTableSize; // Hash Size
uniform uint numInstances;

// --- SPH Kernels (Poly6) ---
// W(r, h) = (315 / (64 * pi * h^9)) * (h^2 - r^2)^3
float Poly6(float r2, float h) {
    float h2 = h * h;
    if (r2 < 0 || r2 > h2) return 0.0;
    float diff = h2 - r2;
    return (315.0 / (64.0 * 3.14159 * pow(h, 9))) * diff * diff * diff;
}

// --- Helper: Grid Index ---
uint GetHash(ivec3 cell) {
    const uint p1 = 73856093u;
    const uint p2 = 19349663u;
    const uint p3 = 83492791u;

    uint n = (uint(cell.x) * p1) ^ (uint(cell.y) * p2) ^ (uint(cell.z) * p3);
    return n % hashTableSize;
}

ivec3 GetGridCell(vec3 pos) {
    vec3 offsetPos = pos + vec3(globalBounds);
    
    // Implicit Grid Dim (Match previous implementation)
    ivec3 gridDim = ivec3(floor((globalBounds * 2.0) / cellSize));

    ivec3 cell = ivec3(floor(offsetPos / cellSize));
    return clamp(cell, ivec3(0), gridDim - ivec3(1));
}

void main() {
    uint i = gl_GlobalInvocationID.x;
    if (i >= numInstances) return;

    vec3 myPos = sortedTransforms[i].position;
    FluidMaterial myMat = entityFluidMaterials[instanceToEntityIndex[gridPairs[i].instanceID]];

    if (myMat.isActive == 0) {
        //sortedMotions[i].density = 0.0; // Keep existing or zero?
        return;
    }

    float density = 0.0;
    float mass = sortedMotions[i].mass;
    float h = cellSize; // Smoothing Radius
    float h2 = h * h;
    
    // Self-Density
    density += mass * Poly6(0.0, h);

    // Neighbor Search
    ivec3 myCell = GetGridCell(myPos);

    for (int z = -1; z <= 1; ++z) {
        for (int y = -1; y <= 1; ++y) {
            for (int x = -1; x <= 1; ++x) {
                
                // No Boundary Check!
                ivec3 neighbor = myCell + ivec3(x, y, z);
                
                uint neighborHash = GetHash(neighbor);
                int startIndex = gridHead[neighborHash];
                
                if (startIndex != -1) {
                    for (uint k = uint(startIndex); k < numInstances; ++k) {
                        
                        // Optimization: Break on Hash Mismatch
                        if (gridPairs[k].cellID != neighborHash) break;
                        
                        if (i == k) continue;

                        vec3 otherPos = sortedTransforms[k].position;
                        vec3 r = myPos - otherPos;
                        float r2 = dot(r, r);

                        if (r2 < h2) {
                            float otherMass = sortedMotions[k].mass;
                            density += otherMass * Poly6(r2, h);
                        }
                    }
                }
            }
        }
    }
    
    // Avoid Zero Density (Vacuum)
    if (density < myMat.restDensity) density = myMat.restDensity;

    // Write Back
    sortedMotions[i].density = density;
}
