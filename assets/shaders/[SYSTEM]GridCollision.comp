#version 430

layout(local_size_x = 64) in;

struct Transform {
    vec3 position;
    vec4 rotation;
    vec3 scale;
};

struct Motion {
    vec3 velocity;
    float mass;
    vec3 acceleration;
    float density;
};

struct Bound {
    float size;
    uint isSphere;
    float bounciness;
    float friction;
    uint isActive;
};

struct FluidMaterial {
    float restDensity;
    float viscosity;
    float stiffness;
    uint isActive;
};

struct GridPair {
    uint cellID;
    uint instanceID;
};


layout(std430, binding = 4) buffer EntityBounds {
    Bound entityBounds[];
};
layout(std430, binding = 8) buffer InstanceToEntityIndex {
    uint instanceToEntityIndex[];
};

layout(std430, binding = 9) buffer GridHead {
    int gridHead[];
};
layout(std430, binding = 10) buffer GridPairs {
    GridPair gridPairs[];
};

layout(std430, binding = 11) buffer SortedTransforms {
    Transform sortedTransforms[];
};
layout(std430, binding = 12) buffer SortedMotions {
    Motion sortedMotions[];
};

layout(std430, binding = 13) buffer EntityFluidMaterials {
    FluidMaterial entityFluidMaterials[];
};


uniform float deltaTime;
uniform float globalBounds;
uniform float cellSize;
uniform uint hashTableSize;
uniform uint numInstances;

// --- Helper: Grid Index ---
uint GetHash(ivec3 cell) {
    const uint p1 = 73856093u;
    const uint p2 = 19349663u;
    const uint p3 = 83492791u;

    uint n = (uint(cell.x) * p1) ^ (uint(cell.y) * p2) ^ (uint(cell.z) * p3);
    return n % hashTableSize;
}

ivec3 GetGridCell(vec3 pos) {
    vec3 offsetPos = pos + vec3(globalBounds);

    // Implicit Grid Dim (Match previous implementation)
    ivec3 gridDim = ivec3(floor((globalBounds * 2.0) / cellSize));

    ivec3 cell = ivec3(floor(offsetPos / cellSize)); // Removed clamp
    return clamp(cell, ivec3(0), gridDim - ivec3(1));
}

void main() {
    uint i = gl_GlobalInvocationID.x;
    if (i >= numInstances) return;

    vec3 myPos = sortedTransforms[i].position;
    vec3 myVel = sortedMotions[i].velocity;
    float myMass = sortedMotions[i].mass;

    // Bounds are NOT sorted, we must index them by OriginalID -> EntityID
    uint myOriginalID = gridPairs[i].instanceID;
    Bound myBound = entityBounds[instanceToEntityIndex[myOriginalID]];
    if (myBound.isActive == 0) return;

    float myRadius = myBound.size * 0.5;

    // World Boundary Collision (Box)
    float limit = globalBounds - myRadius;

    // Y Floor
    if (myPos.y < -limit) {
        myPos.y = -limit;
        if (myVel.y < 0) myVel.y *= -myBound.bounciness;
    } else if (myPos.y > limit) {
        myPos.y = limit;
        if (myVel.y > 0) myVel.y *= -myBound.bounciness;
    }

    // X Walls
    if (myPos.x < -limit) {
        myPos.x = -limit;
        if (myVel.x < 0) myVel.x *= -myBound.bounciness;
    } else if (myPos.x > limit) {
        myPos.x = limit;
        if (myVel.x > 0) myVel.x *= -myBound.bounciness;
    }

    // Z Walls
    if (myPos.z < -limit) {
        myPos.z = -limit;
        if (myVel.z < 0) myVel.z *= -myBound.bounciness;
    } else if (myPos.z > limit) {
        myPos.z = limit;
        if (myVel.z > 0) myVel.z *= -myBound.bounciness;
    }

    vec3 totalCorrection = vec3(0.0);
    float numCorrections = 0.0;

    vec3 totalVelocityChange = vec3(0.0);

    ivec3 myCell = GetGridCell(myPos);

    // Neighbor Search
    for (int z = -1; z <= 1; ++z) {
        for (int y = -1; y <= 1; ++y) {
            for (int x = -1; x <= 1; ++x) {

                ivec3 neighbor = myCell + ivec3(x, y, z);

                uint neighborHash = GetHash(neighbor);
                int startIndex = gridHead[neighborHash];

                if (startIndex != -1) {
                    // Linear Scan of the neighbor cell
                    for (uint k = uint(startIndex); k < numInstances; ++k) {

                        // Optimization: Check if we left the cell (Sorted property)
                        if (gridPairs[k].cellID != neighborHash) break;

                        if (i == k) continue; // Skip self

                        vec3 otherPos = sortedTransforms[k].position;
                        uint otherOriginalID = gridPairs[k].instanceID;
                        Bound otherBound = entityBounds[instanceToEntityIndex[otherOriginalID]];
                        float otherRadius = otherBound.size * 0.5;

                        // Check Fluid Status
                        FluidMaterial myMat = entityFluidMaterials[instanceToEntityIndex[myOriginalID]];
                        FluidMaterial otherMat = entityFluidMaterials[instanceToEntityIndex[otherOriginalID]];

                        // If BOTH are fluid, skip Hard Collision (Let SPH handle it)
                        if (myMat.isActive == 1 && otherMat.isActive == 1) continue;

                        // Collision Logic (Sphere-Sphere)
                        vec3 dir = myPos - otherPos;
                        float distSq = dot(dir, dir);
                        float minParams = myRadius + otherRadius;

                        if (distSq < minParams * minParams && distSq > 0.000001) {
                            float dist = sqrt(distSq);
                            vec3 normal = dir / dist;
                            float penetration = minParams - dist;

                            // Position Correction (Accumulate)
                            vec3 correction = normal * penetration;
                            totalCorrection += correction;
                            numCorrections += 1.0;

                            // Velocity Reflection
                            vec3 otherVel = sortedMotions[k].velocity;
                            float otherMass = sortedMotions[k].mass;

                            vec3 relVel = myVel - otherVel;
                            float velAlongNormal = dot(relVel, normal);

                            if (velAlongNormal < 0) {
                                float restitution = min(myBound.bounciness, otherBound.bounciness);
                                if (abs(velAlongNormal) < 0.5) restitution = 0.0; // Resting threshold

                                float j = -(1.0 + restitution) * velAlongNormal;
                                j /= (1.0/myMass + 1.0/otherMass);

                                vec3 impulse = j * normal;
                                totalVelocityChange += impulse / myMass;

                                // Friction (Simple)
                                vec3 tangent = relVel - (velAlongNormal * normal);
                                float tangentLen = length(tangent);
                                if (tangentLen > 0.0001) {
                                    tangent /= tangentLen;
                                    float friction = sqrt(myBound.friction * otherBound.friction);
                                    float jTangent = -dot(relVel, tangent);
                                    jTangent /= (1.0/myMass + 1.0/otherMass);

                                    vec3 fImpulse;
                                    if (abs(jTangent) < j * friction) fImpulse = jTangent * tangent;
                                    else fImpulse = -j * friction * tangent;

                                    totalVelocityChange += fImpulse / myMass;
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    // Apply Accumulated Position Correction
    if (numCorrections > 0.0) {
        myPos += totalCorrection / numCorrections;
    }

    // Apply Accumulated Velocity Change (Averaged)
    if (numCorrections > 0.0) {
        myVel += totalVelocityChange / numCorrections;
    }

    // Nan/Inf Safety & Final Clamp
    if (isnan(myPos.x) || isinf(myPos.x)) myPos = vec3(0.0);

    // Hard Clamp to Global Bounds (Safety Net)
    float safetyLimit = globalBounds - myRadius;
    myPos = clamp(myPos, vec3(-safetyLimit), vec3(safetyLimit));

    // Write Back
    sortedTransforms[i].position = myPos;
    sortedMotions[i].velocity = myVel;
}