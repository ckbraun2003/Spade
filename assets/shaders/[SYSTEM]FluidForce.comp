#version 430 core

layout(local_size_x = 64) in;

struct Transform {
    vec3 position;
    vec4 rotation;
    vec3 scale;
};

struct Motion {
    vec3 velocity;
    float mass;
    vec3 acceleration;
    float density;
};

struct FluidMaterial {
    float restDensity;
    float viscosity;
    float stiffness;
    uint isActive;
};

struct GridPair {
    uint cellID;
    uint instanceID;
};

// --- Buffers ---
layout(std430, binding = 11) buffer SortedTransforms {
    Transform sortedTransforms[];
};
layout(std430, binding = 12) buffer SortedMotions {
    Motion sortedMotions[];
};
layout(std430, binding = 6) buffer InstanceMotions {
    Motion instanceMotions[];
};
layout(std430, binding = 8) buffer InstanceToEntityIndex {
    uint instanceToEntityIndex[];
};
layout(std430, binding = 13) buffer EntityFluidMaterials {
    FluidMaterial entityFluidMaterials[];
};

layout(std430, binding = 9) buffer GridHead {
    int gridHead[];
};
layout(std430, binding = 10) buffer GridPairs {
    GridPair gridPairs[];
};

// --- Uniforms ---
layout(location = 4) uniform float deltaTime;
layout(location = 15) uniform float globalBounds;
layout(location = 16) uniform float cellSize;
layout(location = 17) uniform uint hashTableSize; // Hash Size
layout(location = 18) uniform uint numInstances;

// --- SPH Kernels ---
// Spiky Gradient: -45 / (pi * h^6) * (h - r)^2 * normalize(r)
vec3 SpikyGradient(vec3 r, float h) {
    float rLen = length(r);
    if (rLen <= 0.0 || rLen >= h) return vec3(0.0);

    float diff = h - rLen;
    float coef = -45.0 / (3.14159 * pow(h, 6));

    return coef * diff * diff * (r / rLen);
}

// Viscosity Laplacian: 45 / (pi * h^6) * (h - r)
float ViscosityLaplacian(float rLen, float h) {
    if (rLen <= 0.0 || rLen >= h) return 0.0;
    return (45.0 / (3.14159 * pow(h, 6))) * (h - rLen);
}

// --- Helper: Grid Index ---
uint GetHash(ivec3 cell) {
    const uint p1 = 73856093u;
    const uint p2 = 19349663u;
    const uint p3 = 83492791u;

    uint n = (uint(cell.x) * p1) ^ (uint(cell.y) * p2) ^ (uint(cell.z) * p3);
    return n % hashTableSize;
}

ivec3 GetGridCell(vec3 pos) {
    vec3 offsetPos = pos + vec3(globalBounds);
    
    // Implicit Grid Dim (Match previous implementation)
    ivec3 gridDim = ivec3(floor((globalBounds * 2.0) / cellSize));
    
    ivec3 cell = ivec3(floor(offsetPos / cellSize));
    return clamp(cell, ivec3(0), gridDim - ivec3(1));
}

void main() {
    uint i = gl_GlobalInvocationID.x;
    if (i >= numInstances) return;

    vec3 myPos = sortedTransforms[i].position;
    vec3 myVel = sortedMotions[i].velocity; // Current Velocity
    float myDensity = sortedMotions[i].density;

    // Safety
    if (myDensity <= 0.0001) {
        // Divide by zero protection
        return;
    }

    FluidMaterial myMat = entityFluidMaterials[instanceToEntityIndex[gridPairs[i].instanceID]];

    if (myMat.isActive == 0) return; // Skip solids

    float pressure = myMat.stiffness * (myDensity - myMat.restDensity);
    float viscosity = myMat.viscosity;

    // Wait... if pressure < 0?
    // Usually max(0.0, stiffness * ...). But negative pressure (tension) causes clumping.
    // Standard SPH clamps pressure to 0.
    if (pressure < 0.0) pressure = 0.0;

    vec3 pressureForce = vec3(0.0);
    vec3 viscosityForce = vec3(0.0);

    float h = cellSize;
    float h2 = h * h;
    ivec3 myCell = GetGridCell(myPos);

    for (int z = -1; z <= 1; ++z) {
        for (int y = -1; y <= 1; ++y) {
            for (int x = -1; x <= 1; ++x) {

                ivec3 neighbor = myCell + ivec3(x, y, z);

                uint neighborHash = GetHash(neighbor);
                int startIndex = gridHead[neighborHash];

                if (startIndex != -1) {
                    for (uint k = uint(startIndex); k < numInstances; ++k) {

                        // Optimization: Break on Hash Mismatch
                        if (gridPairs[k].cellID != neighborHash) break;

                        if (i == k) continue;

                        vec3 otherPos = sortedTransforms[k].position;
                        vec3 r = myPos - otherPos;
                        float r2 = dot(r, r);

                        if (r2 < h2) {
                            float dist = sqrt(r2);
                            FluidMaterial otherMat = entityFluidMaterials[instanceToEntityIndex[gridPairs[k].instanceID]];

                            if (otherMat.isActive == 1) {
                                // FLUID INTERACTION
                                float otherDensity = sortedMotions[k].density;
                                if (otherDensity < 1.0) otherDensity = 1.0;

                                float otherPressure = otherMat.stiffness * (otherDensity - otherMat.restDensity);
                                if (otherPressure < 0.0) otherPressure = 0.0;

                                float otherMass = sortedMotions[k].mass;

                                // Pressure Force: -mass * (pi + pj) / (2 * rho) * gradW
                                // Formula variation: -mass * (pi/rho^2 + pj/rho^2) * gradW
                                // MÃ¼ller SPH: f_pressure = -sum(mass * (pi + pj)/(2 * rho_j) * gradW) ? No.
                                // Standard: f_pressure = -sum(mass * (pi + pj)/(2 * otherDensity) * gradW) is asymmetric?

                                // Symmetric formula
                                float pTerm = (pressure + otherPressure) / (2.0 * otherDensity);
                                pressureForce -= otherMass * pTerm * SpikyGradient(r, h);

                                // Viscosity Force
                                vec3 velDiff = sortedMotions[k].velocity - myVel;
                                float lapW = ViscosityLaplacian(dist, h);
                                viscosityForce += myMat.viscosity * otherMass * (velDiff / otherDensity) * lapW;

                            } else {
                                // SOLID INTERACTION (One-way coupling)
                                // Treat solid as having high pressure? Or just use Collision resolution?
                                // Since we have GridCollision enabled for Solid-Fluid,
                                // we can rely on that for "Hard" non-penetration.
                                // But Soft repulsion (Pressure) helps stability.
                                // Approximation: Treat solid as a dense static fluid particle.

                                // vec3 gradW = SpikyGradient(diff, h);
                                // pressureForce -= otherMass * (myPressure / otherDensity) * gradW; // Push away
                            }
                        }
                    }
                }
            }
        }
    }

    // Apply Forces (F = ma -> a = F/m)
    // We update acceleration directly.
    // Since mass cancels out in SPH derivation usually (F/rho), we just add F_total / Rho.

    vec3 force = pressureForce + viscosityForce;
    if (myDensity > 0.001) {
        sortedMotions[i].acceleration += force / myDensity;
    }
}
